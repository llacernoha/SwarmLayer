<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Mini-Consola de Métricas</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    body { margin: 0; background: #0b0f14; color: #cdd6f4; }
    header {
      padding: 12px 16px;
      background: #0e131a;
      border-bottom: 1px solid #1d2633;
      display: flex; gap: 12px; align-items: center;
    }
    select, button {
      background: #111827; color: #e5e7eb;
      border: 1px solid #374151; border-radius: 6px;
      padding: 6px 8px; cursor: pointer;
    }
    #stats { margin-left: auto; opacity: .9; font-size: 12px; border: none; padding: 0; background: transparent; }
    #consoleWrap { height: calc(100vh - 56px); overflow: auto; }
    pre { margin: 0; padding: 12px 16px; white-space: pre-wrap; word-break: break-word; line-height: 1.35; }
    .http { color: #93c5fd; }
    .p2p  { color: #fca5a5; }
    .muted { opacity: .6; }
    .line { border-bottom: 1px dashed #1f2937; padding: 6px 0; }
  </style>
</head>
<body>
<header>
  <div>Ventana:
    <select id="window">
      <option value="5">Últimos 5 min</option>
      <option value="10">Últimos 10 min</option>
      <option value="15">Últimos 15 min</option>
      <option value="30">Últimos 30 min</option>
      <option value="60">Última 1 h</option>
    </select>
  </div>
  <button id="clearBtn" title="Limpiar consola">Limpiar</button>
  <div id="stats" class="muted">—</div>
</header>

<div id="consoleWrap">
  <pre id="console"></pre>
</div>

<script>
  // Máximo de líneas que mantenemos cuando estás al fondo (para no crecer infinito).
  // No se recorta mientras estás leyendo arriba.
  const CONSOLE_MAX_LINES = 2000;

  let windowMinutes = 5;
  let items = [];         // datos
  let sse;
  let lastRenderedIndex = 0; // cuántos items ya están pintados

  const $console = document.getElementById("console");
  const $wrap = document.getElementById("consoleWrap");
  const $window = document.getElementById("window");
  const $stats = document.getElementById("stats");
  const $clear = document.getElementById("clearBtn");

  function pad(n) { return n.toString().padStart(2, "0"); }
  function fmtTime(ms) {
    const d = new Date(ms);
    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }
  function fmtBytes(n) {
    if (!n) return "0 B";
    const units = ["B","KB","MB","GB","TB"];
    let i = 0, val = n;
    while (val >= 1024 && i < units.length - 1) { val /= 1024; i++; }
    const decimals = val < 10 && i > 0 ? 1 : 0;
    return `${val.toFixed(decimals)} ${units[i]}`;
  }
  function fmtPct(part, total) {
    if (!total) return "0%";
    return `${((part * 100) / total).toFixed(1)}%`;
  }

  function lineHtml(m) {
    const isHttp = (m.source || "").toLowerCase() === "http";
    const cls = isHttp ? "http" : "p2p";
    const sender = isHttp ? "-" : (m.sender || "-");
    return [
      `<span class="muted">[${fmtTime(m.time)}]</span>`,
      `<span class="${cls}">${(m.source || "").toUpperCase()}</span>`,
      `sender=${sender}`,
      `receiver=${m.receiver}`,
      `size=${fmtBytes(m.sizeBytes)}`,
      `frag=${m.fragmentUrl}`
    ].join("  ");
  }

  // Pinta SOLO las nuevas líneas (incremental)
  function appendNewLines() {
    const frag = document.createDocumentFragment();
    for (let i = lastRenderedIndex; i < items.length; i++) {
      const m = items[i];
      const div = document.createElement("div");
      div.className = "line";
      div.innerHTML = lineHtml(m);
      frag.appendChild(div);
    }
    $console.appendChild(frag);
    lastRenderedIndex = items.length;
  }

  // Recalcula y pinta el panel de estadísticas (no toca las líneas)
  function renderStats() {
    const totals = items.reduce((acc, m) => {
      const bytes = m.sizeBytes || 0;
      const isHttp = (m.source || "").toLowerCase() === "http";
      acc.total += bytes;
      if (isHttp) acc.http += bytes; else acc.p2p += bytes;
      return acc;
    }, { total: 0, http: 0, p2p: 0 });

    $stats.textContent =
            `Eventos: ${items.length}  •  Total: ${fmtBytes(totals.total)}  •  ` +
            `HTTP: ${fmtBytes(totals.http)} (${fmtPct(totals.http, totals.total)})  •  ` +
            `P2P: ${fmtBytes(totals.p2p)} (${fmtPct(totals.p2p, totals.total)})  •  ` +
            `Ventana: ${windowMinutes} min`;
  }

  // Aplica poda por ventana SOLO si estás al fondo (para no mover la vista)
  function pruneByWindowIfAtBottom() {
    const atBottom = $wrap.scrollTop + $wrap.clientHeight >= $wrap.scrollHeight - 8;
    if (!atBottom) return; // no toques nada si el usuario está leyendo arriba

    const cutoff = Date.now() - windowMinutes * 60 * 1000;
    // Calcula cuántos hay al principio que caen fuera de la ventana
    let removeCount = 0;
    for (let i = 0; i < items.length; i++) {
      if (items[i].time < cutoff) removeCount++; else break;
    }
    if (removeCount > 0) {
      items.splice(0, removeCount);
      // Elimina los primeros removeCount nodos DOM
      for (let i = 0; i < removeCount; i++) {
        if ($console.firstChild) $console.removeChild($console.firstChild);
      }
      lastRenderedIndex = Math.max(0, lastRenderedIndex - removeCount);
    }
  }

  // Recorte por máximo de líneas SOLO si estás al fondo
  function trimMaxLinesIfAtBottom() {
    const atBottom = $wrap.scrollTop + $wrap.clientHeight >= $wrap.scrollHeight - 8;
    if (!atBottom) return;

    const extra = items.length - CONSOLE_MAX_LINES;
    if (extra > 0) {
      items.splice(0, extra);
      for (let i = 0; i < extra; i++) {
        if ($console.firstChild) $console.removeChild($console.firstChild);
      }
      lastRenderedIndex = Math.max(0, lastRenderedIndex - extra);
    }
  }

  // Render principal: solo añade nuevas líneas y actualiza stats
  function renderIncremental() {
    const atBottom = $wrap.scrollTop + $wrap.clientHeight >= $wrap.scrollHeight - 8;

    appendNewLines();
    renderStats();

    // Si estabas abajo, baja al final para ver lo nuevo
    if (atBottom) {
      $wrap.scrollTop = $wrap.scrollHeight;
    }
  }

  async function loadInitial(minutes) {
    const res = await fetch(`/ktor/metrics?minutes=${minutes}`);
    if (!res.ok) {
      console.error("Error cargando histórico:", res.status);
      return;
    }
    const data = await res.json();
    // Ordena por tiempo para pintar en orden
    items = (data.items || []).sort((a, b) => a.time - b.time);

    // Construcción inicial del DOM
    $console.innerHTML = "";
    lastRenderedIndex = 0;
    appendNewLines();
    renderStats();
    // Al cargar, situamos al fondo
    $wrap.scrollTop = $wrap.scrollHeight;
  }

  function ensureSSE() {
    if (sse) sse.close();
    sse = new EventSource("/ktor/metrics/live");

    sse.addEventListener("metric", (e) => {
      const raw = (e.data || "").trim();
      if (!(raw.startsWith("{") || raw.startsWith("["))) return;
      try {
        const m = JSON.parse(raw);
        items.push(m);
        pruneByWindowIfAtBottom(); // poda por ventana solo si estás abajo
        trimMaxLinesIfAtBottom();  // recorte por máximo solo si estás abajo
        renderIncremental();       // añade SOLO la nueva línea
      } catch (err) {
        console.error("No se pudo parsear SSE:", err, "raw=", raw);
      }
    });

    sse.onopen  = () => console.log("[SSE] conectado");
    sse.onerror = (e) => console.warn("[SSE] error/desconexión:", e);
  }

  $window.addEventListener("change", async (e) => {
    windowMinutes = parseInt(e.target.value, 10);
    await loadInitial(windowMinutes);
  });

  $clear.addEventListener("click", () => {
    items = [];
    $console.innerHTML = "";
    lastRenderedIndex = 0;
    renderStats();
  });

  // Poda periódica: solo si estás abajo (no mover vista)
  setInterval(() => {
    pruneByWindowIfAtBottom();
    trimMaxLinesIfAtBottom();
  }, 5000);

  (async function init() {
    windowMinutes = parseInt($window.value, 10);
    await loadInitial(windowMinutes);
    ensureSSE();
  })();
</script>
</body>
</html>
