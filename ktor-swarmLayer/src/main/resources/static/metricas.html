<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Métricas P2P/HTTP — Realtime</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: Consolas, monospace; margin: 20px; background:#1e1e1e; color:#ddd; }
    h2 { color:#eee; margin-bottom:8px; }
    select { background:#2b2b2b; color:#ddd; border:1px solid #444; padding:6px 8px; border-radius:4px; }
    canvas { max-width:100%; background:#2b2b2b; border-radius:8px; padding:8px; }
    .row { display:flex; gap:12px; align-items:center; margin-bottom:8px; flex-wrap:wrap; }
    small { color:#aaa }
  </style>
</head>
<body>
<h2>Tráfico global SwarmLayer</h2>
<div class="row">
  <label for="timeRange">Rango de tiempo:</label>
  <select id="timeRange">
    <option value="5">Últimos 5 min</option>
    <option value="10" selected>Últimos 10 min</option>
    <option value="30">Últimos 30 min</option>
    <option value="60">Última hora</option>
    <option value="120">Últimas 2h</option>
    <option value="240">Últimas 4h</option>
  </select>
  <small id="status">— conectando…</small>
</div>

<canvas id="trafficChart" height="130"></canvas>

<script>
  const ctx = document.getElementById('trafficChart').getContext('2d');
  const BUCKET_MS = 10_000;

  let chart;
  let timeline = [];                    // array de timestamps (inicio de bucket)
  let buckets = new Map();              // ts -> { p2p: number, http: number, peers: Set<string> }
  let windowMinutes = 10;
  let es;                               // EventSource

  const clamp = (v) => (isFinite(v) && !isNaN(v)) ? v : 0;

  function floorBucket(ts) { return Math.floor(ts / BUCKET_MS) * BUCKET_MS; }

  function createTimeline(now, minutes) {
    const start = Math.floor((now - minutes*60*1000) / BUCKET_MS) * BUCKET_MS;
    const end = Math.floor(now / BUCKET_MS) * BUCKET_MS; // bucket "actual" excluido al graficar
    const arr = [];
    for (let t = start; t < end; t += BUCKET_MS) arr.push(t);
    return arr;
  }

  function ensureBuckets() {
    const now = Date.now();
    const newTimeline = createTimeline(now, windowMinutes);
    timeline = newTimeline;

    // recortar añejos
    const first = newTimeline[0], last = newTimeline[newTimeline.length - 1];
    for (const key of buckets.keys()) {
      if (key < first || key > last) buckets.delete(key);
    }
    // asegurar todos
    for (const t of newTimeline) {
      if (!buckets.has(t)) buckets.set(t, { p2p: 0, http: 0, peers: new Set() });
    }
  }

  function ingest(metric) {
    // métrica con forma { time, source, sizeBytes, sender, receiver }
    const b = floorBucket(metric.time);
    if (!timeline.length) return;
    const first = timeline[0], last = timeline[timeline.length - 1];
    if (b < first || b > last) return;  // fuera de ventana

    if (!buckets.has(b)) buckets.set(b, { p2p: 0, http: 0, peers: new Set() });
    const slot = buckets.get(b);

    const src = String(metric.source || '').toLowerCase();
    if (src === 'p2p') slot.p2p += clamp(metric.sizeBytes);
    else if (src === 'http') slot.http += clamp(metric.sizeBytes);

    if (metric.sender) slot.peers.add(metric.sender);
    if (metric.receiver) slot.peers.add(metric.receiver);
  }

  function toChartData() {
    const labels = timeline.map(t => new Date(t).toLocaleTimeString());
    const p2p = timeline.map(t => +(clamp(buckets.get(t)?.p2p || 0) / 1024).toFixed(2));
    const http = timeline.map(t => +(clamp(buckets.get(t)?.http || 0) / 1024).toFixed(2));
    const peers = timeline.map(t => (buckets.get(t)?.peers.size || 0));
    return { labels, p2p, http, peers };
  }

  function render() {
    const data = toChartData();
    if (!chart) {
      chart = new Chart(ctx, {
        type: "line",
        data: {
          labels: data.labels,
          datasets: [
            { label: "P2P (KB)",  data: data.p2p,  borderColor: "#7CFC00", borderWidth: 1.3, tension: 0.1, fill: false, pointRadius: 0 },
            { label: "HTTP (KB)", data: data.http, borderColor: "#00BFFF", borderWidth: 1.3, tension: 0.1, fill: false, pointRadius: 0 },
            { label: "Peers activos", data: data.peers, borderColor: "#FFA500", borderWidth: 1, borderDash: [4,4], tension: 0.1, fill: false, pointRadius: 0, yAxisID: "yPeers" }
          ]
        },
        options: {
          interaction: { mode: "index", intersect: false },
          animation: false,
          scales: {
            x: { ticks:{color:"#aaa"}, grid:{color:"#333"}, title:{display:true, text:"Tiempo", color:"#bbb"} },
            y: { beginAtZero:true, suggestedMin:0, suggestedMax:100, ticks:{color:"#aaa"}, grid:{color:"#333"}, title:{display:true, text:"KB transferidos", color:"#bbb"} },
            yPeers: { beginAtZero:true, suggestedMax:10, position:"right", ticks:{color:"#ffb347"}, grid:{drawOnChartArea:false}, title:{display:true, text:"Peers activos", color:"#ffb347"} }
          },
          plugins: { legend: { labels: { color: "#ccc" } } }
        }
      });
    } else {
      chart.data.labels = data.labels;
      chart.data.datasets[0].data = data.p2p;
      chart.data.datasets[1].data = data.http;
      chart.data.datasets[2].data = data.peers;
      chart.update("none");
    }
  }

  async function loadHistory() {
    ensureBuckets();
    const res = await fetch(`/ktor/metrics?minutes=${windowMinutes}`, { cache: "no-store" });
    if (res.ok) {
      const arr = await res.json();
      for (const m of arr) ingest(m);
    }
    render();
  }

  function startSSE() {
    if (es) { es.close(); es = null; }
    const status = document.getElementById('status');

    try {
      es = new EventSource('/ktor/metrics/stream');
      status.textContent = "— en tiempo real";
      es.onmessage = (ev) => {
        const m = JSON.parse(ev.data);
        ensureBuckets();   // puede haber cambiado ventana/tiempo
        ingest(m);
        render();
      };
      es.onerror = () => { status.textContent = "— reconectando…"; };
    } catch {
      status.textContent = "— SSE no disponible";
    }
  }

  document.getElementById("timeRange").addEventListener("change", async (e) => {
    windowMinutes = +e.target.value || 10;
    buckets.clear();
    await loadHistory();
  });

  // refresco suave de eje X (por si el reloj avanza y la ventana se desplaza)
  setInterval(() => { ensureBuckets(); render(); }, 10_000);

  // bootstrap:
  (async function init(){
    await loadHistory();
    startSSE();
  })();
</script>
</body>
</html>
